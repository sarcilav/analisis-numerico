Una buena aproximaci\'on a este problema puede ser una
mezcla de los splines lineales, con los c\'ubicos y los b-splines.
La idea consiste en manejar la curva cerrada como un pol\'igono, de lados
muy peque\~nos, esto con el fin de al menos garantizar que el spline
toque los puntos iniciales, claramente esta es idea esta dada por los
splines lineales. Ahora bien entre cada uno de los puntos
adyacentes construir $recticas$ definidas como pasos sobra la
curva c\'ubica que brindan los splines c\'ubicos, y al final como determinar
esos pasos nos lo brinda los b-splines, como par\'ametros,
para curvas par\'ametricas para $x$ y $y$ respectivamente.
\begin{verbatim}
calcular_cubicas(n,  x[])
    gamma [n+1]
    delta [n+1]
    D [n+1]
    i;
    /* Este es el sistema de matriz banda que
       tenemos que solucionar para obtener las
       derivadas
       [2 1       ] [D[0]]   [3(x[1] - x[0])  ]
       |1 4 1     | |D[1]|   |3(x[2] - x[0])  |
       |  1 4 1   | | .  | = |      .         |
       |    ..... | | .  |   |      .         |
       |     1 4 1| | .  |   |3(x[n] - x[n-2])|
       [       1 2] [D[n]]   [3(x[n] - x[n-1])]
       usando operaciones elementales filas
       podemos convertir la matriz a una superior
       triangular, y simplemente usar sustitucion regresiva.
       Luego D[i] es son las derivadas en los puntos intermedios
       */

    gamma[0] = 1.0f/2.0f
    for ( i = 1; i < n; i++)
      gamma[i] = 1/(4-gamma[i-1])
    endfor
    gamma[n] = 1/(2-gamma[n-1])

    delta[0] = 3*(x[1]-x[0])*gamma[0]
    for ( i = 1; i < n; i++)
      delta[i] = (3*(x[i+1]-x[i-1])-delta[i-1])*gamma[i]
    endfor
    delta[n] = (3*(x[n]-x[n-1])-delta[n-1])*gamma[n]

    D[n] = delta[n]
    for ( i = n-1; i >= 0; i--)
      D[i] = delta[i] - gamma[i]*D[i+1]
    endfor

    /* Ahora calculamos los coeficientes de cubicos y los guardamos en
      en Cubic[i]*/
    Cubic C [] /*Cubic es una clase o estructura que contienen los coeficientes cubicos */
    for ( i = 0; i < n; i++)
      C[i] = Cubic(x[i], D[i], 3*(x[i+1] - x[i]) - 2*D[i] - D[i+1],
                       2*(x[i] - x[i+1]) + D[i] + D[i+1])
      /*Cubic(d,c,b,a) para ax^3 + bx^2 + cx +d*/
    endfor
    return C
  }
\end{verbatim}
Este c\'odigo que mostramos anteriormente nos sirve para obtener las curvas c\'ubicas
par\'ametricas, de tal forma que $f_x(t) = at^3+bt^2+ct+d$ y $f_y(t) = et^3+ft^2+gt+h$.
Con el m\'etodo para obtener las curvas c\'ubicas ya si podremos mostrar
como ser\'ia el resto de la idea.
\begin{verbatim}
    steps = 12
    Cubic X = calcular_cubicas(n, points.x)
    Cubic Y = calcular_cubicas(n, points.y)
    Polygon p
    p.add_point(X[0].eval(0),Y[0].eval(0) /*eval es la funcion que se
     encarga de evaluar el polinomio cubico en un valor determinado
    */
    for ( i = 0; i < n ; i++)
      for ( j = 1; j <= STEPS; j++)
        u = j / (float) STEPS
        p.addPoint(X[i].eval(u),Y[i].eval(u))
      endfor
    endfor
\end{verbatim}


